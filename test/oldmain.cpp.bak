#include "nocturnus/roguelike.hpp"
#include <csignal>
#include <cstdio>

struct Entity {
	ANSIColor color;
	vec2<uint16> pos;
};

struct Player {
	vec2<uint16> pos = { 5, 5 };
};

struct Enemy {
	vec2<uint16> pos = { 16, 1 };
};

Enemy enemy;

void draw(Terminal& terminal, Roguelike& rogue, Player& player) {
	// terminal.clear_screen();

	terminal.update_buffer();
	rogue.render_map();

	// if(enemy.pos.x > player.pos.x) {
	// 	enemy.pos.x -= 1;
	// } else {
	// 	enemy.pos.x += 1;
	// }
	//
	// if(enemy.pos.y > player.pos.y) {
	// 	enemy.pos.y -= 1;
	// } else {
	// 	enemy.pos.y += 1;
	// }

	terminal.putstring(0, 20, ("X: " + std::to_string(player.pos.x)  + " Y: " + std::to_string(player.pos.y)).c_str());
	terminal.putstring(0, 21, ("Under character: '" + std::string(1, rogue.getchar(player.pos.x, player.pos.y)) + "'").c_str());
}

/**
 * BUGS
 * - Collision not working on windows (top and left only)
 * - Windows terminal blinking when moving
 *
 * NEW STUFF TO ADD
 * - Add real time turn (sleep on while loop end)
 * - Windows background
 * - Windows bold
 * - Double buffer drawing
 * 
 * 
 * */


int main() {
	// Terminal realted methods
	Terminal terminal = Terminal(); // In this case used as the underlayer
	terminal.hide_cursor();

	// Roguelike related methods
	Roguelike rogue = Roguelike(terminal, terminal.term_col(), terminal.term_row()); // Used for collision
	rogue.make_room(18, 8, 20, 10, '#');

	// std::vector<Entity> = {
	// 	{ player.pos, ANSI }
	// }

	std::printf("width: %d height: %d", terminal.term_col(), terminal.term_row());
	terminal.getkey();

	Player player;
	terminal.set_bold(ANSIColor::YELLOW);
	terminal.putchar(player.pos.x, player.pos.y, 'C');

	// terminal.set_bold(ANSIColor::RED);
	// terminal.putchar(enemy.pos.x, enemy.pos.y, 'R');


	terminal.clear_screen();
	terminal.set_color(ANSIColor::YELLOW);
	terminal.show_message(0, 0, "Press any key to start...");

	char ch;
	while((ch = terminal.getkey())) {
		vec2<uint16> newpos = player.pos;
		if(ch == 'w') {
			newpos.y -= 1;
		} else if(ch == 's') {
			newpos.y += 1;
		}

		if(ch == 'a') {
			newpos.x -= 1;
		} else if(ch == 'd') {
			newpos.x += 1;
		}

		// If not colliding with a wall
		if(!rogue.willcollide(newpos, '#')) {
			terminal.putchar(player.pos.x, player.pos.y, ' ');
			player.pos = newpos;
		}
		terminal.set_color(ANSIColor::YELLOW);
		terminal.putchar(newpos.x, newpos.y, '@');

		// Debug warning
		if(ch == 'e') {
			terminal.show_warning("Testing warning");
			rogue.render_map();
		}

		// Update screen
		draw(terminal, rogue, player);
	}
}



